<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Speculative decoding | </title>
<meta name="keywords" content="first" />
<meta name="description" content="A brief overview of speculative decoding, detailing the roots of LLM inference slowdowns and how algorithmic level changes can improve generation speed!">
<meta name="author" content="
Author: &nbspAni Nrusimha
&nbsp | &nbsp Editor: &nbspMinyoung Huh">
<link rel="canonical" href="https://canonical.url/to/page" />
<link crossorigin="anonymous" href="https://minyoungg.github.io/mlscale/assets/css/stylesheet.min.012b9a75b78c05a5b3111bea2ffe80bb9c7a658de709126230287fb6db7016a7.css" integrity="" rel="preload stylesheet" as="style">
<link rel="icon" href="https://minyoungg.github.io/mlscale/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://minyoungg.github.io/mlscale/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://minyoungg.github.io/mlscale/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://minyoungg.github.io/mlscale/apple-touch-icon.png">
<link rel="mask-icon" href="https://minyoungg.github.io/mlscale/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.119.0">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Speculative decoding" />
<meta property="og:description" content="A brief overview of speculative decoding, detailing the roots of LLM inference slowdowns and how algorithmic level changes can improve generation speed!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://minyoungg.github.io/mlscale/posts/speculative-decoding.html" /><meta property="og:image" content="https://minyoungg.github.io/mlscale/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-13T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2023-09-13T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://minyoungg.github.io/mlscale/papermod-cover.png"/>

<meta name="twitter:title" content="Speculative decoding"/>
<meta name="twitter:description" content="A brief overview of speculative decoding, detailing the roots of LLM inference slowdowns and how algorithmic level changes can improve generation speed!"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Speculative decoding",
      "item": "https://minyoungg.github.io/mlscale/posts/speculative-decoding.html"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Speculative decoding",
  "name": "Speculative decoding",
  "description": "A brief overview of speculative decoding, detailing the roots of LLM inference slowdowns and how algorithmic level changes can improve generation speed!",
  "keywords": [
    "first"
  ],
  "articleBody": " Speculative decoding combines two things I love: clever systems optimizations and probability. As a result, we have a lot to get through. Lets dig in!\nBackground: the problem Suppose you want to run an LLM interactively on your local machine. You have a single GPU, say a GTX 4090. It’s a high-end card, costing $1600, but it’s much cheaper than an A100 or H100 might be. What challenges do you face?\nFirst, the model may not fit on your GPU. Llama2-70B would require 140GB stored in 16-bit precision, 6x larger than what can fit on your device. This problem can be solved by using a smaller model, opting for lower precision through quantization, or both. You compromise and load a 30B parameter model in 4-bit precision. This requires 15GB of storage, leaving you with ample space.\nHowever, you discover that, despite being able to fit your model, it runs at a glacial pace. Huggingface transformers can generate only a few tokens per second at best. Sometimes, it doesn’t even achieve that. You search online for optimized implementations and come across something like exllama that is written in C++ and CUDA. By switching to this well-written optimized code, you find the throughput is closer to 50 tokens per second. That’s an order of magnitude improvement without any change in hardware!\nThis observation gets you thinking. Surely, 50 tokens per second isn’t the limit, right? There must be a way to achieve faster speeds. Reflecting on the process, you realize that your input prompt processes through the model at a stunning rate, 60x faster than token generation. Mathematically, the prompt undergoes the same procedure as the generated tokens, yet for some reason, one is nearly two orders of magnitude faster than the other. Why is this the case? Both algorithms show 100% utilization on nvidia-smi!\nWe’ll dive into speculative decoding shortly. But first, let’s delve into GPU Architecture! From the architecture whitepaper, your RTX4090 looks like this under the hood:\nFig 1. Architecture diagram of RTX 4090. Zooming in on those streaming multiprocessors (SM), we observe the following structure:\nFig 2. Zoomed in diagram of the streaming multiprocessor (SM). What does this all mean? And what does it have to do with the generation being so slow? Lets go over all the acronyms in these two pictures:\nThe processing hierarchy, from top to bottom: An NVIDIA GPU is split into various GPU Processing Clusters (GPCs). An RTX4090 has 7. A GPC is split into various streaming multiprocessors (SMs). An RTX4090 has 128 SMs, sixteen per GPC. An SM is split into four processing blocks. On an RTX4090, each SM has four processing blocks. The job hierarchy, from bottom to top: A thread is an individual unit of work. It executes computation in serial. 32 threads are organized in a warp. All threads in a warp run at the same time on the same SM and processing block. An SM can have up to 64 warps scheduled. Several warps are organized in a thread block. All threads in a thread block are guaranteed to run on the same SM, but not necessarily at the same time. A thread block can have up to 1024 threads, or 32 warps. Thread blocks can (optionally, and only on very recent hardware) be organized into thread block clusters, which run on the same GPU Processing Cluster. The memory hierarchy, from bottom to top (IMPORTANT): Registers / L0 cache - holds per thread or warp. The L0 cache also contains information on which warp is currently running, an SM can have up to 64 warps queued but can only run 4 at a time. One per processing block. L1 / shared memory[^1] - this holds information shared between all threads in a thread block. It is quite small (128KB / SM, or 16MB across all SMs), but very fast. Can be explicitly accessed. One per SM L2 - 72 MB (in this case) of shared cache. Shared between many SMs and GPCs. Some GPUs have one L2 cache, while some have multiple. Main memory - 24GB of memory. Incredibly slow to access versus L0/L1, and much slower than L2 Misc., from most relevant to least: Tensor cores do the sweet sweet number crunching used in matmuls. They can only do matrix multiplications of block sizes of blocks eight to sixteen on a side. There is one per SM. The CUDA Cores (labeled FP32/Int32 on the diagram) do most of the standard operations outside of matmuls, such as addition, multiplication, etc. They can work on any size, and are roughly an order of magnitude slower than the tensor cores. The SFU handles \"special\" functions, like log, sin, and sqrt The RT core does ray tracing. Ignore for now. TPC, PolyMorph, and Tex are all pure texture/graphics related. Ignore for now. For the curious, all that nvidia-smi measures is how often a kernel is executing on the GPU. Any kernel on any part of the GPU would show up as GPU utilization. Adding two vectors together in shared memory on a single SM can achieve 100% utilization for the entire GPU based on nvidia-smi, purely because at every clock step one kernel is executing one step.\nThis is why something can be insanely slow and still show 100% nvidia-smi usage!\nWhy did we go into GPU Architecture? GPU architecture explains precisely why there is a slowdown between processing input prompts (also training) and generation!\n(TLDR) On small-batch auto-regressive generation for LLMs, GPUs waste compute cycles on moving the model weights instead of actually computing the output!\nTo understand why, let's consider the first part of the MLP in a single layer of our transformer. Running the feedforward linear layer on our GPU requires executing several operations. Given a weight matrix \\( W \\) (defined as \\( d_{\\mathsf{model}} \\times d_{\\mathsf{ff}} \\)) and an input \\( X \\) (defined as \\( n \\times d_{\\mathsf{model}} \\)), we produce an output \\( Y \\) (defined as \\( n \\times d_{\\mathsf{ff}} \\)) in the following manner:\nDivide the problem into several thread blocks. For each thread block, read the relevant submatrix in \\( W \\) and \\( X \\) into shared memory. Compute the relevant submatrix of \\( Y \\) and store it in shared memory[a]. Write this submatrix to the main memory. At the very minimum, our operations will consist of:\n\\( d_{\\mathsf{model}} d_{\\mathsf{ff}} + nd_{\\mathsf{model}} + nd_{\\mathsf{ff}} \\) reads and writes transitioning from main memory to shared memory.[b] \\( nd_{\\mathsf{model}}d_{\\mathsf{ff}} \\) floating point operations, commonly referred to as flops. For the llama2 30B model, where \\( d_{\\mathsf{model}} = 6656 \\) and \\( d_{\\mathsf{ff}} = 17920 \\), and given a prompt of 1024 tokens, we calculate:\n\\( 2 \\times (1024 \\times 6656 + 1024 \\times 17920 + 6656 \\times 17920) = 274 \\)MB in 16-bit reads and writes, or 110MB when utilizing four-bit weight quantization. Additionally, it necessitates 122GFlops of 16-bit arithmetic.\nIf we momentarily set aside all complexities and make a series of generalized assumptions, we can estimate the time required for this operation by dividing the first quantity by the GPU's memory bandwidth, and the second value by the GPU's maximum 16-bit throughput. With our GPU's bandwidth being 1TB/sec and its peak 16-bit throughput reaching 330 trillion floating point operations every second, we derive the following approximate times:\n0.3ms for reads/writes without quantization, or 0.1ms with. 0.3ms for computation.[c] Bearing in mind that this calculation is for a batch of 1024 tokens, this translates to less than a microsecond per individual token. But let's re-evaluate these figures for just one token:\nHow do we proceed with this? With a tally of 60MB/238MB reads/writes with and without quantization respectively, we have only 120MFlops worth of calculations to perform. The resulting times are:\n0.25ms for reads and writes when not using quantization, or 0.05ms with it. 0.3 microseconds (or .0003ms) for computation. Given the inability to utilize tensor cores, a more accurate figure might be 0.003ms. To our surprise, we find that the performance is almost three orders of magnitude slower on a per-token basis! We are spending more time reading and writing than actually making calculations. [a] Note that I'm glossing over a ton of detail in how you divide the problem. [b] The division of the problem as well as the details of reads and writes are ignored in this post, but have a massive impact. You can't actually achieve this level of efficiency in reads and writes easily in practice. Note, for example, that in this case the size of the reads and writes exceeds the size of the L1/L2 cache without quantization. [c] Do you add or take the maximum of these numbers? The answer is complicated. Ideally, we use computation to hide communication, but this rarely works out perfectly in practice. So… speculative decoding? What if we made generation more like prefill? How would we do this? We need our model to process more than one token at once. However, to process a token, we need to know that it is part of our output, which we are trying to determine in the first place!\nWe can’t generate multiple tokens simultaneously without violating joint distribution assumptions1. To achieve accurate and faithful generation, we need to guess. To do this, we employ an ancient method of problem-solving: guess and check.\nThe model we use to guess can vary. In Blockwise Parallel Decoding for Deep Autoregressive Models, different heads on the same model predicts multiple future tokens (fine-tuned to do so), and the original head checks them. This approach still suffers from the joint distribution problem1. Alternatively, we could perform autoregressive decoding on a smaller model.\nIt’s important to note that strictly more computation (floating-point operations) is done with speculative decoding, yet we can achieve higher generation throughput. The reason it still saves time is that loading the weights of the small model is much cheaper than the large one, and each token you correctly guess for the future saves an entire load of the model.\nSpeculative decoding is simply a method to guess in a systematic way using a smaller LLM and to check in a manner that ensures our outputs are identical to using the original. This is what happens in Fast Inference from Transformers via Speculative Decoding and Accelerating Large Language Model Decoding with Speculative Sampling. This may remind you of rejection sampling; we generate candidates using the smaller model and employ the larger model to decide whether we want to accept or reject the sample. We will get into the details shortly.\nThe final piece of this narrative is the mathematics that makes the outputs of this process identical to the original. Many naive algorithms accidentally oversample outputs that are more common in the smaller model, as they will be guessed by the smaller model more frequently. If you aren’t concerned about exact replication, you can achieve slightly faster results, which is what Speculative Decoding with Big Little Decoder does.\nProbability time For a detailed explanation, refer to the original paper. A brief summary is provided below.\nLet \\( p(x) \\) be the large model's probability distribution, and \\( q(x) \\) represent the smaller model's distribution. We'll be employing a variation of rejection sampling.\nSample \\( n \\) tokens from \\( q(x) \\), called \\( x_1 ... x_n \\). Generate the logits of the \\( n \\) tokens from \\( p(x) \\) For each token \\( x_i \\), decide whether to accept it based on the following criteria: If \\( q(x_i) \u003c p(x_i) \\), accept and move to the next token Otherwise, sample a random number \\( r \\) from \\( [0,1] \\) and compare it to some value \\( v \\). We calculate \\( v \\) as \\( \\frac{p(x_i)}{q(x_i)} \\). If it is less than \\( v \\) , accept anyways If it was greater than \\( v \\), reject, break the loop, and sample the current token from the distribution \\( p(x)-q(x) \\) where it is positive, normalized to be a probability distribution. There are several levels of rigor to prove that this algorithm works. We now detail the most intuitive, albeit hand-wavy, explanation:\nAssuming \\( q(x_i) \u003e p(x_i) \\), the probability that our system selects token \\( x_i \\) is given by \\( q(x_i) \\cdot \\frac{p(x_i)}{q(x_i)} = p(x_i) \\). When \\( q(x_i) \u003c p(x_i) \\), the probability that our system selects the token is \\( q(x_i) \\) from the initial sampling, plus \\( \\frac{p(x_i)-q(x_i)}{C} \\) from the resampling, where \\( C \\) is a normalization constant. It can be proven that \\( C \\) is one because the probabilities across all options must sum to one.\nA more rigorous proof is available in the paper, where the distribution specified in step 5 is calculated, along with the probability of any token being sampled from this distribution. The normalization constant is also derived, and the distribution is computed.\nIn practice, we can leverage the probability distributions of the two models to estimate the number of tokens the smaller model is likely to predict. From the above explanations, the acceptance probability can be calculated as:\nDefine \\( D \\) as a distance metric: \\( D(p,q) = \\sum_x |\\frac{p(x) - q(x)}{2}| = 1-\\sum_x \\min(p(x), q(x)) \\). This is a symmetric divergence for those interested. The acceptance probability \\( \\beta \\) for a specific token \\( x_i \\) is \\( \\frac{p(x_i)}{q(x_i)} \\) if \\( q(x_i)\u003ep(x_i) \\) and 1 otherwise. This can also be represented as \\( \\min(1, \\frac{p(x_i)}{q(x_i)})=\\frac{\\min(p(x_i),q(x_i))}{q(x_i)} \\). We sample from \\( q(x) \\), hence the general acceptance probability \\( \\alpha = E(\\beta) = \\sum_x q(x) \\frac{\\min(p(x),q(x))}{q(x)} =1-E(D(p,q)) \\). If \\( \\gamma \\) is the number of tokens predicted by the smaller model, then the expected throughput of tokens per iteration for the large model, given an arbitrary acceptance probability \\( \\alpha \\), is visualized in the following figure:\nNot bad! However, in the context of this paper and others, \\( \\alpha \\) often hovers around 0.6 to 0.7. The acceptance probability depends on not only how accurate the smaller model is but also its relative generation speed compared to the larger model. In the worst case scenario where the smaller model fails to predict beyond a single token at every iteration, speculative decoding would run slower than not having it in the first place! For LLMs, most works rely on using smaller network from the same model/data family. In the paper we just discussed one would use T5-XXL with T5-BASE/LARGE or LAMDA (137B) with LAMDA (2~8B), something usually in the order of magnitude smaller (in more modern model lingo terms, using LLama2-70B for the bigger model and Llama2-7B as the smaller one). Then the compute break down would look something this:\nFig 3. Simplified transfomer trace diagram. Figure 5. from `Fast Inference from Transformers via Speculative Decoding '. In summary, smaller model is typically much tinier than the original, making its guessing speed negligible compared to the larger model's checking process. The performance speed up is proprtionate to the small model's ability to approximate the larger one. But... we still aren't even close! Using speculative decoding, even with an excellent approximation, we won't generate more than 3-5 tokens per iteration, denoted as \\( \\gamma \\) previously. This might result in a potential 3x speedup at best, which is still short from bridging the theoretical performance gap that is in the orders of magnitude larger.\nEfforts have been made to bridge this gap. The paper \"Accelerating LLM Inference with Staged Speculative Decoding\" introduces two main innovations:\nEmploying multiple levels of speculative decoding. Generating multiple branched predictions simultaneously. The latter is somewhat challenging due to nuances in KV caching. The paper doesn't disclose their acceptance probability, and their outcomes are modest. Their method increase the speedup from 2.5x to 3x, but at the expense of introducing substantial complexity.\nPersonally, I believe there's significant potential yet to be unlocked in this domain. If I were to speculate on the sources of future advancements, I'd anticipate the following:\nEarly stopping or AlBERT-style strategies: If the logits of the smaller model could expedite the final decoding. This could be further enhanced using distillation. One might also adopt aggressive staging, performing only the essential computation needed to reject a proposal. Adoption of techniques like Paged Attention to explore multiple branches efficiently at once. Implementing structured pruning in tandem with distillation when designing the smaller model. This approach might yield efficient models boasting higher acceptance probabilities. Conclusion This post is close to 3000 words, when blog posts are usually kept to the smaller side of a thousand. Congratulations on reading this far, and I hoped you learned something!\nImagine you are playing a guessing game with an LLM of the city you grew up in. Given that you are reading this article, it gives a 30% probability of the bay area, and 20% of new york city. If you were generating multiple tokens at once, you might say that for the first token, new and san have 20/30% probability, and for the second york and fran_ have 20/30% probability. A sampling algorithm might pick san york city or even new francity, which are impossible. ↩︎ ↩︎\n",
  "wordCount" : "2851",
  "inLanguage": "en",
  "datePublished": "2023-09-13T00:00:00Z",
  "dateModified": "2023-09-13T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Ani Nrusimha"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://minyoungg.github.io/mlscale/posts/speculative-decoding.html"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "https://minyoungg.github.io/mlscale/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://minyoungg.github.io/mlscale/">Home</a></div>
    <h1 class="post-title">
      Speculative decoding
    </h1>
    <div class="post-description">
      A brief overview of speculative decoding, detailing the roots of LLM inference slowdowns and how algorithmic level changes can improve generation speed!
    </div>
    <div class="post-meta"><span title='2023-09-13 00:00:00 +0000 UTC'>September 13, 2023</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;
Author: &nbspAni Nrusimha
&nbsp | &nbsp Editor: &nbspMinyoung Huh

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#background-the-problem" aria-label="Background: the problem">Background: the problem</a></li>
                <li>
                    <a href="#well-dive-into-speculative-decoding-shortly-but-first-lets-delve-into-gpu-architecture" aria-label="We&amp;rsquo;ll dive into speculative decoding shortly. But first, let&amp;rsquo;s delve into GPU Architecture!">We&rsquo;ll dive into speculative decoding shortly. But first, let&rsquo;s delve into GPU Architecture!</a><ul>
                        
                <li>
                    <a href="#" aria-label="The processing hierarchy, from top to bottom:">The processing hierarchy, from top to bottom:</a></li>
                <li>
                    <a href="#" aria-label="The job hierarchy, from bottom to top:">The job hierarchy, from bottom to top:</a></li>
                <li>
                    <a href="#" aria-label="The memory hierarchy, from bottom to top (IMPORTANT):">The memory hierarchy, from bottom to top (IMPORTANT):</a></li>
                <li>
                    <a href="#" aria-label="Misc., from most relevant to least:">Misc., from most relevant to least:</a></li></ul>
                </li>
                <li>
                    <a href="#why-did-we-go-into-gpu-architecture" aria-label="Why did we go into GPU Architecture?">Why did we go into GPU Architecture?</a></li>
                <li>
                    <a href="#so-speculative-decoding" aria-label="So&amp;hellip; speculative decoding?">So&hellip; speculative decoding?</a></li>
                <li>
                    <a href="#probability-time" aria-label="Probability time">Probability time</a></li>
                <li>
                    <a href="#" aria-label="But... we still aren&#39;t even close!">But... we still aren't even close!</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content">

<!-- KaTeX -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>


<p>Speculative decoding combines two things I love: clever systems optimizations and probability. As a result, we have a lot to get through. Lets dig in!</p>
<h3 id="background-the-problem">Background: the problem<a hidden class="anchor" aria-hidden="true" href="#background-the-problem">#</a></h3>
<p>Suppose you want to run an LLM interactively on your local machine.
You have a single GPU, say a GTX 4090. It&rsquo;s a high-end card, costing $1600, but it&rsquo;s much cheaper than an A100 or H100 might be. What challenges do you face?</p>
<p>First, the model may not fit on your GPU. <a href="https://ai.meta.com/llama/">Llama2-70B</a> would require 140GB stored in 16-bit precision, 6x larger than what can fit on your device. This problem can be solved by using a smaller model, opting for lower precision through quantization, or both.
You compromise and load a 30B parameter model in 4-bit precision. This requires 15GB of storage, leaving you with ample space.</p>
<p>However, you discover that, despite being able to fit your model, it runs at a glacial pace. Huggingface transformers can generate only a few tokens per second at best. Sometimes, it doesn&rsquo;t even achieve that. You search online for optimized implementations and come across something like <a href="https://github.com/turboderp/exllamav2">exllama</a> that is written in C++ and CUDA. By switching to this well-written optimized code, you find the throughput is closer to 50 tokens per second. That&rsquo;s an order of magnitude improvement without any change in hardware!</p>
<p>This observation gets you thinking. Surely, 50 tokens per second isn&rsquo;t the limit, right? There must be a way to achieve faster speeds. Reflecting on the process, you realize that your input prompt processes through the model at a stunning rate, <strong>60x faster</strong> than token generation. Mathematically, the prompt undergoes the same procedure as the generated tokens, yet for some reason, one is nearly two orders of magnitude faster than the other. Why is this the case? Both algorithms show 100% utilization on nvidia-smi!</p>
<br/>
<h3 id="well-dive-into-speculative-decoding-shortly-but-first-lets-delve-into-gpu-architecture">We&rsquo;ll dive into speculative decoding shortly. But first, let&rsquo;s delve into GPU Architecture!<a hidden class="anchor" aria-hidden="true" href="#well-dive-into-speculative-decoding-shortly-but-first-lets-delve-into-gpu-architecture">#</a></h3>
<p>From <a href="https://images.nvidia.com/aem-dam/Solutions/Data-Center/l4/nvidia-ada-gpu-architecture-whitepaper-v2.1.pdf">the architecture whitepaper</a>, your RTX4090 looks like this under the hood:</p>
<p class="cssclass1 cssclass2">
  <img src="./images/speculative_decoding/img1.png" alt="Logo" title="Logo title">
  <p style="color:grey;font-size: 0.6vw;">Fig 1. Architecture diagram of RTX 4090.</em>
</p>
<p>Zooming in on those streaming multiprocessors (SM), we observe the following structure:</p>
<p class="cssclass1 cssclass2">
  <img src="./images/speculative_decoding/img2.png" alt="Logo" title="Logo title">
  <p style="color:grey;font-size: 0.6vw;">Fig 2. Zoomed in diagram of the streaming multiprocessor (SM). </em>
</p>
<p>What does this all mean? And what does it have to do with the generation being so slow?
Lets go over all the acronyms in these two pictures:</p>
<div style="padding: 15px 15px 15px 25px; border: 1px solid #e0e0e0; border-radius: 5px; font-size: 0.6vw;">
<h4>The processing hierarchy, from top to bottom:</h4>
<ol>
    <li>An NVIDIA GPU is split into various GPU Processing Clusters (GPCs). An RTX4090 has 7.</li>
    <li>A <u style="color:#e76f51">GPC</u> is split into various streaming multiprocessors (SMs). An RTX4090 has 128 SMs, sixteen per GPC.</li>
    <li>An <u style="color:#e76f51">SM</u> is split into four processing blocks. On an RTX4090, each SM has four processing blocks.</li>
</ol>
<h4>The job hierarchy, from bottom to top:</h4>
<ol>
    <li>A <u style="color:#e76f51">thread</u> is an individual unit of work. It executes computation in serial.</li>
    <li>32 threads are organized in a <u style="color:#e76f51">warp</u>. All threads in a warp run at the same time on the same SM and processing block. An SM can have up to 64 warps scheduled.</li>
    <li>Several warps are organized in a <u style="color:#e76f51">thread block</u>. All threads in a thread block are guaranteed to run on the same SM, but not necessarily at the same time. A thread block can have up to 1024 threads, or 32 warps.</li>
    <li>Thread blocks can (optionally, and only on very recent hardware) be organized into <u style="color:#e76f51">thread block clusters</u>, which run on the same GPU Processing Cluster.</li>
</ol>
<h4>The memory hierarchy, from bottom to top (IMPORTANT):</h4>
<ol>
    <li><u style="color:#e76f51">Registers / L0 cache</u> - holds per thread or warp. The L0 cache also contains information on which warp is currently running, an SM can have up to 64 warps queued but can only run 4 at a time. One per processing block.</li>
    <li><u style="color:#e76f51">L1 / shared memory</u>[^1] - this holds information shared between all threads in a thread block. It is quite small (128KB / SM, or 16MB across all SMs), but very fast. Can be explicitly accessed. One per SM</li>
    <li><u style="color:#e76f51">L2</u> - 72 MB (in this case) of shared cache. Shared between many SMs and GPCs. Some GPUs have one L2 cache, while some have multiple.</li>
    <li><u style="color:#e76f51">Main memory</u> - 24GB of memory. Incredibly slow to access versus L0/L1, and much slower than L2</li>
</ol>
<h4>Misc., from most relevant to least:</h4>
<ol>
    <li><u style="color:#e76f51">Tensor</u> cores do the sweet sweet number crunching used in matmuls. They can only do matrix multiplications of block sizes of blocks eight to sixteen on a side. There is one per SM.</li>
    <li>The <u style="color:#e76f51">CUDA Cores</u> (labeled FP32/Int32 on the diagram) do most of the standard operations outside of matmuls, such as addition, multiplication, etc. They can work on any size, and are roughly an order of magnitude slower than the tensor cores.</li>
    <li>The <u style="color:#e76f51">SFU</u> handles "special" functions, like log, sin, and sqrt</li>
    <li>The <u style="color:#e76f51">RT core</u> does ray tracing. Ignore for now.</li>
    <li><u style="color:#e76f51">TPC, PolyMorph, and Tex</u> are all pure texture/graphics related. Ignore for now.</li>
</ol>
</div>
<br/>
<p>For the curious, all that nvidia-smi measures is how often a kernel is executing on the GPU. <em>Any</em> kernel on <em>any</em> part of the GPU would show up as GPU utilization. Adding two vectors together in shared memory on a single SM can achieve 100% utilization for the entire GPU based on nvidia-smi, purely because at every clock step one kernel is executing one step.</p>
<p><strong>This is why something can be insanely slow and still show 100% nvidia-smi usage!</strong></p>
<br/>
<h3 id="why-did-we-go-into-gpu-architecture">Why did we go into GPU Architecture?<a hidden class="anchor" aria-hidden="true" href="#why-did-we-go-into-gpu-architecture">#</a></h3>
<p>GPU architecture explains precisely why there is a slowdown between processing input prompts (also training) and generation!</p>
<blockquote>
<p>(TLDR) On small-batch auto-regressive generation for LLMs, GPUs waste compute cycles on moving the model weights instead of actually computing the output!</p>
</blockquote>
<p>To understand why, let's consider the first part of the MLP in a single layer of our transformer. Running the feedforward linear layer on our GPU requires executing several operations. Given a weight matrix \( W \) (defined as \( d_{\mathsf{model}} \times d_{\mathsf{ff}} \)) and an input \( X \) (defined as \( n \times d_{\mathsf{model}} \)), we produce an output \( Y \) (defined as \( n \times d_{\mathsf{ff}} \)) in the following manner:</p>
<ol>
    <li>Divide the problem into several thread blocks.</li>
    <li>For each thread block, read the relevant submatrix in \( W \) and \( X \) into shared memory.</li>
    <li>Compute the relevant submatrix of \( Y \) and store it in shared memory<sup><a href="#footnote2">[a]</a></sup>.</li>
    <li>Write this submatrix to the main memory.</li>
</ol>
<p>At the very minimum, our operations will consist of:</p>
<ul>
    <li>\( d_{\mathsf{model}} d_{\mathsf{ff}} + nd_{\mathsf{model}} + nd_{\mathsf{ff}} \) reads and writes transitioning from main memory to shared memory.<sup><a href="#footnote3">[b]</a></sup></li>
    <li>\( nd_{\mathsf{model}}d_{\mathsf{ff}} \) floating point operations, commonly referred to as flops.</li>
</ul>
<p>For the llama2 30B model, where \( d_{\mathsf{model}} = 6656 \) and \( d_{\mathsf{ff}} = 17920 \), and given a prompt of 1024 tokens, we calculate:</p>
<p>\( 2 \times (1024 \times 6656 + 1024 \times 17920 + 6656 \times 17920) = 274 \)MB in 16-bit reads and writes, or 110MB when utilizing four-bit weight quantization. Additionally, it necessitates 122GFlops of 16-bit arithmetic.</p>
<p>If we momentarily set aside all complexities and make a series of generalized assumptions, we can estimate the time required for this operation by dividing the first quantity by the GPU's memory bandwidth, and the second value by the GPU's maximum 16-bit throughput. With our GPU's bandwidth being 1TB/sec and its peak 16-bit throughput reaching 330 trillion floating point operations every second, we derive the following approximate times:</p>
<ul>
    <li>0.3ms for reads/writes without quantization, or 0.1ms with.</li>
    <li>0.3ms for computation.<sup><a href="#footnote4">[c]</a></sup></li>
</ul>
<p>Bearing in mind that this calculation is for a batch of 1024 tokens, this translates to less than a microsecond per individual token. But let's re-evaluate these figures for just one token:</p>
<p>How do we proceed with this? With a tally of 60MB/238MB reads/writes with and without quantization respectively, we have only 120MFlops worth of calculations to perform. The resulting times are:</p>
<ul>
    <li>0.25ms for reads and writes when not using quantization, or 0.05ms with it.</li>
    <li>0.3 microseconds (or .0003ms) for computation. Given the inability to utilize tensor cores, a more accurate figure might be 0.003ms.</li>
</ul>
<p>To our surprise, we find that the performance is almost three orders of magnitude slower on a per-token basis! We are spending more time reading and writing than actually making calculations. </p>
<!-- Footnotes -->
<div style="padding: 15px 15px 15px 25px; border: 1px solid #e0e0e0; border-radius: 5px; font-size: 0.6vw;">
<ul id="footnotes" style="list-style-type: none; margin: 0; padding: 0;">
    <li id="footnote2">[a] Note that I'm glossing over a ton of detail in how you divide the problem. </li>
    <li id="footnote3">[b] The division of the problem as well as the details of reads and writes are ignored in this post, but have a massive impact. You can't actually achieve this level of efficiency in reads and writes easily in practice. Note, for example, that in this case the size of the reads and writes exceeds the size of the L1/L2 cache without quantization.</li>
    <li id="footnote4">[c] Do you add or take the maximum of these numbers? The answer is complicated. Ideally, we use computation to hide communication, but this rarely works out perfectly in practice.</li>
</ul>
</div>
<br/>
<h3 id="so-speculative-decoding">So&hellip; speculative decoding?<a hidden class="anchor" aria-hidden="true" href="#so-speculative-decoding">#</a></h3>
<p>What if we made generation more like prefill? How would we do this? We need our model to process more than one token at once. However, to process a token, we need to know that it is part of our output, which we are trying to determine in the first place!</p>
<p>We can&rsquo;t generate multiple tokens simultaneously without violating joint distribution assumptions<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. To achieve accurate and faithful generation, we need to guess. To do this, we employ an ancient method of problem-solving: <em>guess and check</em>.</p>
<p>The model we use to guess can vary. In <a href="https://arxiv.org/abs/1811.03115">Blockwise Parallel Decoding for Deep Autoregressive Models</a>, different heads on the same model predicts multiple future tokens (fine-tuned to do so), and the original head checks them. This approach still suffers from the joint distribution problem<sup id="fnref1:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. Alternatively, we could perform autoregressive decoding on a smaller model.</p>
<p>It&rsquo;s important to note that strictly more computation (floating-point operations) is done with speculative decoding, yet we can achieve higher generation throughput. The reason it still saves time is that loading the weights of the small model is much cheaper than the large one, and each token you correctly guess for the future saves an entire load of the model.</p>
<p>Speculative decoding is simply a method to guess in a systematic way using a smaller LLM and to check in a manner that ensures our outputs are identical to using the original. This is what happens in <a href="https://arxiv.org/abs/2211.17192">Fast Inference from Transformers via Speculative Decoding</a> and <a href="https://arxiv.org/abs/2302.01318">Accelerating Large Language Model Decoding with Speculative Sampling</a>. This may remind you of rejection sampling; we generate candidates using the smaller model and employ the larger model to decide whether we want to accept or reject the sample. We will get into the details shortly.</p>
<p>The final piece of this narrative is the mathematics that makes the outputs of this process identical to the original. Many naive algorithms accidentally oversample outputs that are more common in the smaller model, as they will be guessed by the smaller model more frequently. If you aren&rsquo;t concerned about exact replication, you can achieve slightly faster results, which is what <a href="https://arxiv.org/abs/2302.07863">Speculative Decoding with Big Little Decoder</a> does.</p>
<br/>
<h3 id="probability-time">Probability time<a hidden class="anchor" aria-hidden="true" href="#probability-time">#</a></h3>
<p>For a detailed explanation, refer to <a href="https://arxiv.org/abs/2211.17192">the original paper</a>. A brief summary is provided below.</p> 
<p> Let \( p(x) \) be the large model's probability distribution, and \( q(x) \) represent the smaller model's distribution. We'll be employing a variation of <a href="https://en.wikipedia.org/wiki/Rejection_sampling">rejection sampling</a>.</p>
<ol>
    <li>Sample \( n \) tokens from \( q(x) \), called \( x_1 ... x_n \).</li>
    <li>Generate the logits of the \( n \) tokens from \( p(x) \)</li>
    <li>For each token \( x_i \), decide whether to accept it based on the following criteria:
        <ol>
            <li>If \( q(x_i) < p(x_i) \), accept and move to the next token</li>
            <li>Otherwise, sample a random number \( r \) from \( [0,1] \) and compare it to some value \( v \). We calculate \( v \) as \( \frac{p(x_i)}{q(x_i)} \). </li>
        </ol>
    </li>
    <li>If it is less than \( v \) , accept anyways</li>
    <li>If it was greater than \( v \), reject, break the loop, and sample the current token from the distribution \( p(x)-q(x) \) where it is positive, normalized to be a probability distribution.</li>
</ol>
<p>There are several levels of rigor to prove that this algorithm works. We now detail the most intuitive, albeit hand-wavy, explanation:</p>
<p>Assuming \( q(x_i) > p(x_i) \), the probability that our system selects token \( x_i \) is given by \( q(x_i) \cdot \frac{p(x_i)}{q(x_i)} = p(x_i) \). When \( q(x_i) < p(x_i) \), the probability that our system selects the token is \( q(x_i) \) from the initial sampling, plus \( \frac{p(x_i)-q(x_i)}{C} \) from the resampling, where \( C \) is a normalization constant. It can be proven that \( C \) is one because the probabilities across all options must sum to one.</p>
<p>A more rigorous proof is available in the paper, where the distribution specified in step 5 is calculated, along with the probability of any token being sampled from this distribution. The normalization constant is also derived, and the distribution is computed.</p>
<p>In practice, we can leverage the probability distributions of the two models to estimate the number of tokens the smaller model is likely to predict. From the above explanations, the acceptance probability can be calculated as:</p>
<ol>
    <li>Define \( D \) as a distance metric: \( D(p,q) = \sum_x |\frac{p(x) - q(x)}{2}| = 1-\sum_x \min(p(x), q(x)) \). This is a symmetric divergence for those interested.</li>
    <li>The acceptance probability \( \beta \) for a specific token \( x_i \) is \( \frac{p(x_i)}{q(x_i)} \) if \( q(x_i)>p(x_i) \) and 1 otherwise. This can also be represented as \( \min(1, \frac{p(x_i)}{q(x_i)})=\frac{\min(p(x_i),q(x_i))}{q(x_i)} \).</li>
    <li>We sample from \( q(x) \), hence the general acceptance probability \( \alpha = E(\beta) = \sum_x q(x) \frac{\min(p(x),q(x))}{q(x)} =1-E(D(p,q)) \).</li>
</ol>
<p>If \( \gamma \) is the number of tokens predicted by the smaller model, then the expected throughput of tokens per iteration for the large model, given an arbitrary acceptance probability \( \alpha \), is visualized in the following figure:</p>
<p><img src="./images/speculative_decoding/img3.png" alt="Speculative Decoding Visualization"></p>
<p>Not bad! However, in the context of this paper and others, \( \alpha \) often hovers around 0.6 to 0.7. 
The acceptance probability depends on not only how accurate the smaller model is but also its relative generation speed compared to the larger model. In the worst case scenario where the smaller model fails to predict beyond a single token at every iteration, speculative decoding would run slower than not having it in the first place! For LLMs, most works rely on using smaller network from the same model/data family. In the paper we just discussed one would use T5-XXL with T5-BASE/LARGE or LAMDA (137B) with LAMDA (2~8B), something usually in the order of magnitude smaller (in more modern model lingo terms, using LLama2-70B for the bigger model and Llama2-7B as the smaller one). Then the compute break down would look something this:</p>
<p class="cssclass1 cssclass2">
  <img src="./images/speculative_decoding/img4.png" alt="Logo" title="Logo title">
  <p style="color:grey;font-size: 0.6vw;">Fig 3. Simplified transfomer trace diagram. Figure 5. from `Fast Inference from Transformers via Speculative Decoding
'. </em>
</p>
<p> In summary, smaller model is typically much tinier than the original, making its guessing speed negligible compared to the larger model's checking process. The performance speed up is proprtionate to the small model's ability to approximate the larger one. </p>
<br/>
<h3>But... we still aren't even close!</h3>
<p>Using speculative decoding, even with an excellent approximation, we won't generate more than 3-5 tokens per iteration, denoted as \( \gamma \) previously. This might result in a potential 3x speedup at best, which is still short from bridging the theoretical performance gap that is in the orders of magnitude larger.</p>
<p>Efforts have been made to bridge this gap. The paper <a href="link_to_paper">"Accelerating LLM Inference with Staged Speculative Decoding"</a> introduces two main innovations:</p>
<ol>
    <li>Employing multiple levels of speculative decoding.</li>
    <li>Generating multiple branched predictions simultaneously.</li>
</ol>
<p>The latter is somewhat challenging due to nuances in KV caching. The paper doesn't disclose their acceptance probability, and their outcomes are modest. Their method increase the speedup from 2.5x to 3x, but at the expense of introducing substantial complexity.</p>
<p>Personally, I believe there's significant potential yet to be unlocked in this domain. If I were to speculate on the sources of future advancements, I'd anticipate the following:</p>
<ol>
    <li>Early stopping or AlBERT-style strategies: If the logits of the smaller model could expedite the final decoding.
        <ol type="A">
            <li>This could be further enhanced using distillation.</li>
            <li>One might also adopt aggressive staging, performing only the essential computation needed to reject a proposal.</li>
        </ol>
    </li>
    <li>Adoption of techniques like Paged Attention to explore multiple branches efficiently at once.</li>
    <li>Implementing structured pruning in tandem with distillation when designing the smaller model. This approach might yield efficient models boasting higher acceptance probabilities.</li>
</ol>
<br/>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>This post is close to 3000 words, when blog posts are usually kept to the smaller side of a thousand. Congratulations on reading this far, and I hoped you learned something!</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Imagine you are playing a guessing game with an LLM of the city you grew up in. Given that you are reading this article, it gives a 30% probability of the bay area, and 20% of new york city. If you were generating multiple tokens at once, you might say that for the first token, <em>new</em> and <em>san</em> have 20/30% probability, and for the second <em>york</em> and <em>fran_</em> have 20/30% probability. A sampling algorithm might pick san york city or even new francity, which are impossible.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://minyoungg.github.io/mlscale/tags/first.html">first</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://minyoungg.github.io/mlscale/posts/moe.html">
    <span class="title">« Prev Page</span>
    <br>
    <span>Mixture of Experts (MoE)</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Speculative decoding on twitter"
        href="https://twitter.com/intent/tweet/?text=Speculative%20decoding&amp;url=https%3a%2f%2fminyoungg.github.io%2fmlscale%2fposts%2fspeculative-decoding.html&amp;hashtags=first">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Speculative decoding on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fminyoungg.github.io%2fmlscale%2fposts%2fspeculative-decoding.html&amp;title=Speculative%20decoding&amp;summary=Speculative%20decoding&amp;source=https%3a%2f%2fminyoungg.github.io%2fmlscale%2fposts%2fspeculative-decoding.html">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Speculative decoding on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fminyoungg.github.io%2fmlscale%2fposts%2fspeculative-decoding.html&title=Speculative%20decoding">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Speculative decoding on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fminyoungg.github.io%2fmlscale%2fposts%2fspeculative-decoding.html">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Speculative decoding on whatsapp"
        href="https://api.whatsapp.com/send?text=Speculative%20decoding%20-%20https%3a%2f%2fminyoungg.github.io%2fmlscale%2fposts%2fspeculative-decoding.html">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Speculative decoding on telegram"
        href="https://telegram.me/share/url?text=Speculative%20decoding&amp;url=https%3a%2f%2fminyoungg.github.io%2fmlscale%2fposts%2fspeculative-decoding.html">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://minyoungg.github.io/mlscale/"></a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
